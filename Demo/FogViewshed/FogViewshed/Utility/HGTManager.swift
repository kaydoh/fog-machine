import Foundation
import MapKit
import SwiftEventBus

public class HGTManager {
    static func isFileInDocuments(fileName: String) -> Bool {
        let fileManager: NSFileManager = NSFileManager.defaultManager()
        let documentsPath: String = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0]
        let url = NSURL(fileURLWithPath: documentsPath).URLByAppendingPathComponent(fileName)
        return fileManager.fileExistsAtPath(url.path!)
    }
    
    static func copyHGTFilesToDocumentsDir() {
        let prefs = NSUserDefaults.standardUserDefaults()
        
        // copy the data over to documents dir, if it's never been done.
        if !prefs.boolForKey("hasCopyData") {
            
            let fromPath:String = NSBundle.mainBundle().resourcePath!
            let toPath: String = NSSearchPathForDirectoriesInDomains(.DocumentDirectory, .UserDomainMask, true)[0]
            
            do {
                let fileManager = NSFileManager.defaultManager()
                let resourceFiles:[String] = try fileManager.contentsOfDirectoryAtPath(fromPath)
                
                for file in resourceFiles {
                    if file.hasSuffix(".hgt") {
                        let fromFilePath = fromPath + "/" + file
                        let toFilePath = toPath + "/" + file
                        if (fileManager.fileExistsAtPath(toFilePath) == false) {
                            try fileManager.copyItemAtPath(fromFilePath, toPath: toFilePath)
                            NSLog("Copying " + file + " to documents directory.")
                        }
                    }
                }
                prefs.setValue(true, forKey: "hasCopyData")
            } catch let error as NSError  {
                NSLog("Problem copying files: \(error.localizedDescription)")
            }
        }
    }
    
    static private func getLocalHGTFileMap() -> [String:HGTFile] {
        var hgtFiles:[String:HGTFile] = [String:HGTFile]()
        let documentsUrl:NSURL =  NSFileManager.defaultManager().URLsForDirectory(.DocumentDirectory, inDomains: .UserDomainMask).first!
        do {
            let hgtPaths:[NSURL] = try NSFileManager.defaultManager().contentsOfDirectoryAtURL(documentsUrl, includingPropertiesForKeys: nil, options: NSDirectoryEnumerationOptions()).filter{ $0.pathExtension == "hgt" }

            for hgtpath in hgtPaths {
                hgtFiles[hgtpath.lastPathComponent!] = HGTFile(path: hgtpath)
                
            }
        } catch let error as NSError {
            NSLog("Error displaying HGT file: \(error.localizedDescription)")
        }

        return hgtFiles
    }
    
    static func getLocalHGTFiles() -> [HGTFile] {
        return Array(getLocalHGTFileMap().values)
    }
    
    static func getLocalHGTFileByName(filename:String) -> HGTFile? {
        return getLocalHGTFileMap()[filename]
    }

    /**
     
     Converts a (lat,lon) to an index in the grid.  Used by several classes to map data.
     
     in the indexed returned, (0,0) is lower left; (resolution, resolution) is upper right
 
    */
    static func latLonToIndex(latLon:CLLocationCoordinate2D, boundingBox:AxisOrientedBoundingBox, resolution:Double) -> (Int, Int) {
        let llLat:Double = latLon.latitude
        let llLatGrid:Double = boundingBox.getLowerLeft().latitude
        let yIndex:Int = Int(floor(roundMe((llLat - llLatGrid)*resolution)))
        
        let llLon:Double = latLon.longitude
        let llLonGrid:Double = boundingBox.getLowerLeft().longitude
        let xIndex:Int = Int(floor(roundMe((llLon - llLonGrid)*resolution)))
        return (xIndex, yIndex)
    }
    
    static private func roundMe(d:Double) -> Double {
        let precision:Double = pow(10, 9)
        return Double(round(precision*d)/precision)
    }
    
    /**
     
     see https://dds.cr.usgs.gov/srtm/version2_1/Documentation/Quickstart.pdf for more information
     
     SRTM data are distributed in two levels: SRTM1 (for the U.S. and its territories
     and possessions) with data sampled at one arc-second intervals in latitude and
     longitude, and SRTM3 (for the world) sampled at three arc-seconds. Three
     arc-second data are generated by three by three averaging of the one
     arc-second samples.
     
     Data are divided into one by one degree latitude and longitude tiles in
     "geographic" projection, which is to say a raster presentation with equal
     intervals of latitude and longitude in no projection at all but easy to manipulate
     and mosaic.
     
     File names refer to the latitude and longitude of the lower left corner of
     the tile - e.g. N37W105 has its lower left corner at 37 degrees north
     latitude and 105 degrees west longitude. To be more exact, these
     coordinates refer to the geometric center of the lower left pixel, which in
     the case of SRTM3 data will be about 90 meters in extent.
     
     Height files have the extension .HGT and are signed two byte integers. The
     bytes are in Motorola "big-endian" order with the most significant byte first,
     directly readable by systems such as Sun SPARC, Silicon Graphics and Macintosh
     computers using Power PC processors. DEC Alpha, most PCs and Macintosh
     computers built after 2006 use Intel ("little-endian") order so some byte-swapping
     may be necessary. Heights are in meters referenced to the WGS84/EGM96 geoid.
     Data voids are assigned the value -32768.
     
     SRTM3 files contain 1201 lines and 1201 samples. The rows at the north
     and south edges as well as the columns at the east and west edges of each
     cell overlap and are identical to the edge rows and columns in the adjacent
     cell. SRTM1 files contain 3601 lines and 3601 samples, with similar overlap.

     
     
     
     NOTE:
     For the purpose of this application, we will ignore the first row (top row) and the last column (right column)
     in the hgt files.  This will be done to avoid dealing with the overlap that extists across the hgt files.  
     Doing this will provide a perfect tiling.
     
     */
    static func getElevationGrid(axisOrientedBoundingBox:AxisOrientedBoundingBox) -> ElevationDataGrid {
        
        //SwiftEventBus.post("drawDebugging", sender:axisOrientedBoundingBox.asMKPolygon())
        
        // TODO: pass this in
        let resolutioni:Int = Srtm.SRTM3_RESOLUTION
        let resolutiond:Double = Double(resolutioni)
        
        // this is the size of a cell in degrees
        let cellSizeInDegrees:Double = 1.0/resolutiond
        
        // expand the bounds of the bounding box to snap to the srtm grid size
        
        // lower left
        let llLatCell:Double = axisOrientedBoundingBox.getLowerLeft().latitude
        let llLatGrid:Double = floor(llLatCell) - (cellSizeInDegrees/2.0)
        let llLatCellGrided:Double = llLatGrid + (floor((llLatCell - llLatGrid)*resolutiond)*cellSizeInDegrees)
        
        let llLonCell:Double = axisOrientedBoundingBox.getLowerLeft().longitude
        let llLonGrid:Double = floor(llLonCell) - (cellSizeInDegrees/2.0)
        let llLonCellGrided:Double = llLonGrid + (floor((llLonCell - llLonGrid)*resolutiond)*cellSizeInDegrees)
        
        // upper right
        let urLatCell:Double = axisOrientedBoundingBox.getUpperRight().latitude
        let urLatGrid:Double = floor(urLatCell) - (cellSizeInDegrees/2.0)
        let urLatCellGrided:Double = urLatGrid + (ceil((urLatCell - urLatGrid)*resolutiond)*cellSizeInDegrees)

        let urLonCell:Double = axisOrientedBoundingBox.getUpperRight().longitude
        let urLonGrid:Double = floor(urLonCell) - (cellSizeInDegrees/2.0)
        let urLonCellGrided:Double = urLonGrid + (ceil((urLonCell - urLonGrid)*resolutiond)*cellSizeInDegrees)
        
        // this is the bounding box, snapped to the grid
        let griddedAxisOrientedBoundingBox:AxisOrientedBoundingBox = AxisOrientedBoundingBox(lowerLeft: CLLocationCoordinate2DMake(llLatCellGrided, llLonCellGrided), upperRight: CLLocationCoordinate2DMake(urLatCellGrided, urLonCellGrided))
        
        //SwiftEventBus.post("drawDebugging", sender:griddedAxisOrientedBoundingBox.asMKPolygon())
        
        // get hgt files of interest
        var hgtFilesOfInterest:[HGTFile] = [HGTFile]()
        
        // looping vars
        var iLat:Double = llLatGrid
        let urLat:Double = urLatGrid + 1.0
        
        var iLon:Double = llLonGrid
        let urLon:Double = urLonGrid + 1.0

        // get all the files that are covered by this bounding box
        while(iLon <= urLon) {
            while(iLat <= urLat) {
                let hgtFile:HGTFile? = HGTManager.getLocalHGTFileByName(HGTFile.coordinateToFilename(CLLocationCoordinate2DMake(iLat, iLon), resolution: resolutioni))
                if(hgtFile != nil) {
                    hgtFilesOfInterest.append(hgtFile!)
                }
                iLat = iLat + 1.0
            }
            iLon = iLon + 1.0
        }
        
        
        let elevationDataWidth:Int = HGTManager.latLonToIndex(griddedAxisOrientedBoundingBox.getUpperRight(), boundingBox: griddedAxisOrientedBoundingBox, resolution: resolutiond).1 - HGTManager.latLonToIndex(griddedAxisOrientedBoundingBox.getLowerLeft(), boundingBox: griddedAxisOrientedBoundingBox, resolution: resolutiond).1 + 1
        let elevationDataHeight:Int = HGTManager.latLonToIndex(griddedAxisOrientedBoundingBox.getUpperRight(), boundingBox: griddedAxisOrientedBoundingBox, resolution: resolutiond).0 - HGTManager.latLonToIndex(griddedAxisOrientedBoundingBox.getLowerLeft(), boundingBox: griddedAxisOrientedBoundingBox, resolution: resolutiond).0 + 1
        
        NSLog("elevationDataWidth \(elevationDataWidth)")
        NSLog("elevationDataHeight \(elevationDataHeight)")
        
        // this is the data structure that will contain the elevation data
        var elevationData:[[Int]] = [[Int]](count:elevationDataWidth, repeatedValue:[Int](count:elevationDataHeight, repeatedValue:Srtm.NO_DATA))
        
        // read sections of each file and fill in the martix as needed
        for hgtFileOfInterest:HGTFile in hgtFilesOfInterest {
            
            let hgtFileBoundingBox:AxisOrientedBoundingBox = hgtFileOfInterest.getBoundingBox()
            
            // make sure this hgtfile intersets the bounding box
            if(hgtFileBoundingBox.intersectionExists(griddedAxisOrientedBoundingBox)) {
                // find the intersection
                let hgtAreaOfInterest:AxisOrientedBoundingBox = hgtFileBoundingBox.intersection(griddedAxisOrientedBoundingBox)
                
                SwiftEventBus.post("drawDebugging", sender:hgtAreaOfInterest.asMKPolygon())
                
                // we need to read data from the upper left of the intersection to the lower right of the intersection
                var upperLeftIndex:(Int, Int) = hgtFileOfInterest.latLonToIndex(hgtAreaOfInterest.getUpperLeft())
                var lowerRightIndex:(Int, Int) = hgtFileOfInterest.latLonToIndex(hgtAreaOfInterest.getLowerRight())
                
                // the files are enumerated from top to bottom, left to right, so flip the yIndex
                upperLeftIndex.1 = hgtFileOfInterest.getResolution() - 1 - upperLeftIndex.1
                lowerRightIndex.1 = hgtFileOfInterest.getResolution() - 1 - lowerRightIndex.1
                
                NSLog("upperLeftIndex \(upperLeftIndex.0) \(upperLeftIndex.1)")
                NSLog("lowerRightIndex \(lowerRightIndex.0) \(lowerRightIndex.1)")
                
                NSLog("lowerRightIndex.0 - upperLeftIndex.0 + 1: \(lowerRightIndex.0 - upperLeftIndex.0 + 1)")
                NSLog("lowerRightIndex.1 - upperLeftIndex.1 + 1: \(lowerRightIndex.1 - upperLeftIndex.1 + 1)")
                
                // data row length, 2 bytes for every index
                let dataRowLengthInBytes:Int = 2*(lowerRightIndex.0 - upperLeftIndex.0 + 1)
                
                NSLog("dataRowLengthInBytes \(dataRowLengthInBytes)")
                
                // always skip the first row of data + plus the extra cell in the last column that we don't care about
                var numberOfBytesToStartReadingAt:UInt64 = UInt64((hgtFileOfInterest.getResolution() + 1) * 2)
                
                NSLog("numberOfBytesToStartReadingAt \(numberOfBytesToStartReadingAt)")
                
                // then skip the data until the exact of offset we want to read at
                // account for each row and the last column, AND the offset in the current row
                numberOfBytesToStartReadingAt = numberOfBytesToStartReadingAt + UInt64(((upperLeftIndex.1 * (hgtFileOfInterest.getResolution() + 1)) + upperLeftIndex.0)*2)
                
                NSLog("numberOfBytesToStartReadingAt \(numberOfBytesToStartReadingAt)")
                
                // the last bytes is the start byte plus the number of columns minus one * the size of each row, plus the legth of the last row
                let numberOfBytesUntilLastByteToRead:UInt64 = numberOfBytesToStartReadingAt + UInt64(2*((lowerRightIndex.1 - upperLeftIndex.1)*(hgtFileOfInterest.getResolution() + 1)) + dataRowLengthInBytes)
                
                NSLog("numberOfBytesUntilLastByteToRead \(numberOfBytesUntilLastByteToRead)")
                
                do {
                    let handle:NSFileHandle = try NSFileHandle(forReadingFromURL: hgtFileOfInterest.path)
                    
                    var rowNumber:Int = 0
                    // while there are more rows to read
                    while(numberOfBytesToStartReadingAt <= numberOfBytesUntilLastByteToRead) {
                        handle.seekToFileOffset(numberOfBytesToStartReadingAt)
                        let data:NSData = handle.readDataOfLength(dataRowLengthInBytes)
                        var oneRowOfElevation = [Int16](count: data.length, repeatedValue: Int16(Srtm.NO_DATA))
                        let dataRange = NSRange(location: 0, length: data.length)
                        // read the row into the temp structure
                        data.getBytes(&oneRowOfElevation, range: dataRange)
                        
                        // find the index where this row should be indexed into the large elevationData structure
                        var elevationDataIndex:(Int, Int) = HGTManager.latLonToIndex(hgtAreaOfInterest.getUpperLeft(), boundingBox: griddedAxisOrientedBoundingBox, resolution: resolutiond)
                        elevationDataIndex.1 = elevationDataIndex.1 - rowNumber
                        
                        // the byte order is backwards, so flip it.  Don't think there's a faster way to do this
                        for j in 0 ..< (data.length/2) {
                            elevationData[elevationDataIndex.1][elevationDataIndex.0 + j] = Int(oneRowOfElevation[j].bigEndian)
                        }
                        
                        // seek to the next row
                        numberOfBytesToStartReadingAt = numberOfBytesToStartReadingAt + UInt64((hgtFileOfInterest.getResolution() + 1)*2)
                        rowNumber = rowNumber + 1
                    }
                } catch let error as NSError {
                    NSLog("Error reading HGT file: \(error.localizedDescription)")
                }
            }
        }
   
        return ElevationDataGrid(elevationData: elevationData, boundingBoxAreaExtent: griddedAxisOrientedBoundingBox, resolution: resolutioni)
    }
    
}